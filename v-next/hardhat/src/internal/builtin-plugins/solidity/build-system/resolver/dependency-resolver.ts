import type {
  NpmPackageResolvedFile,
  ProjectResolvedFile,
  Remapping,
  ResolvedFile,
  ResolvedNpmPackage,
  Resolver,
} from "./types.js";

import path from "node:path";

import {
  HardhatError,
  assertHardhatInvariant,
} from "@ignored/hardhat-vnext-errors";
import { ensureError } from "@ignored/hardhat-vnext-utils/error";
import {
  FileNotFoundError,
  exists,
  getFileTrueCase,
  readJsonFile,
  readUtf8File,
} from "@ignored/hardhat-vnext-utils/fs";
import { shortenPath } from "@ignored/hardhat-vnext-utils/path";
import { ResolutionError, resolve } from "@ignored/hardhat-vnext-utils/resolve";

import { AsyncMutex } from "../../../../core/async-mutex.js";

import {
  applyValidRemapping,
  parseRemappingString,
  selectBestRemapping,
} from "./remappings.js";
import { ResolvedFileType } from "./types.js";

// Things to note:
//  - This resolver assumes that the root of the project is the folder with the
//    closest package.json to the config file.
//  - Each file system file is resolved to a single ResolvedFile, with a unique
//    source name.
//  - Files within the project have their relative path as their source name.
//  - Files within npm packages have source names that start with `npm/` and
//    contain the package name and version. e.g. `npm/package@1.2.3/path.sol`.
//  - Files within npm packages that are part of a monorepo are resolved like
//    npm pacakges, but with the version `local`.
//  - This resolver does not support `package.json#exports`.
//  - This resolver fails if an import has a casing different from that of the
//    file system.
//  - We do not allow users to remap the imports present in files within npm
//    packages, by forbidding user remappings with context and starting with
//    `npm/`.
//  - We do allow users to remap imports of non-npm files, including remmapping
//    them into file within npm packages.
//  - Every import in an npm file is either relative or remapped by a remapping
//    generated by the resolver.
//  - A direct import (i.e. not relative) is considered to be local within the
//    the project/package if it is a bare file name (not in a directory), or if
//    the first directory exists in the project/package.
//  - The direct import "hardhat/console.sol" is a special case and it is never
//    considered to be local. And we only remap `hardhat/console.sol`.
//  - Local imports within the project may be remapped by user remappings, but
//    not by the resolver.
//  - Imports into npm packages are always remapped, if not by the user, by the
//    resolver.
//  - Direct local improts within npm package are always remapped by the
//    resolver.

/**
 * A user remapping, parsed, and with its npm package resolved, if any.
 */
interface ResolvedUserRemapping {
  rawFormat: string;
  context: string;
  prefix: string;
  target: string;
  targetNpmPackage?: ResolvedNpmPackage;
}

/**
 * A sentinel value that represents the root source name of the Hardhat project.
 */
const PROJECT_ROOT_SOURCE_NAME_SENTINEL: unique symbol = Symbol();

export class ResolverImplementation implements Resolver {
  readonly #projectRoot: string;
  readonly #userRemappings: ResolvedUserRemapping[];

  /**
   * IMPORTANT: This mutex must be acquired before writing to any of the mutable
   * fields of this class. We do this by using the mutex in the public methods,
   * which don't call each other.
   */
  readonly #mutex = new AsyncMutex();

  /**
   * A map of all the npm dependencies used in the project, and their
   * dependencies.
   *
   * This is more complex than you may expect, as we have to handle:
   *
   *   - The Hardhat project itself, which is treated differently than npm
   *     packages, and is represented by the value
   *     `PROJECT_ROOT_SOURCE_NAME_SENTINEL`.
   *   - The case where a package is installed with a different name than the
   *     package's name in its `package.json`. We refer to the name with which
   *     the package is installed as the "installation name".
   *   - Imports from monorepo packages into the Hardhat project.
   */
  readonly #dependencyMaps: Map<
    ResolvedNpmPackage | typeof PROJECT_ROOT_SOURCE_NAME_SENTINEL,
    Map<
      string, // The installation-name of the package that is being imported
      ResolvedNpmPackage | typeof PROJECT_ROOT_SOURCE_NAME_SENTINEL // The package imported with that name
    >
  > = new Map();

  /**
   * A map of all the prefixes that an npm package needs to set as remappings
   * to avoid being affected by a user remapping.
   *
   * For example, if a package `foo` has an import `import "dep/File.sol";`,
   * and the user remaps `dep/=nope/`, it could break `foo`'s import.
   *
   * To avoid this situation we set all the prefixes that `foo` needs unaffected
   * by the user remapping, with a higher presedence than user remappings.
   */
  readonly #localPrefixesByPackage: Map<ResolvedNpmPackage, Set<string>> =
    new Map();

  /**
   * We use this map to ensure that we only resolve each file once.
   **/
  readonly #resolvedFileBySourceName: Map<string, ResolvedFile> = new Map();

  /**
   * Creates a new Resolver.
   *
   * @param projectRoot The absolute path to the Hardhat project root.
   * @param userRemappingStrings The remappings provided by the user.
   * @param workingDirectory The absolute path to the working directory.
   */
  public static async create(
    projectRoot: string,
    userRemappingStrings: string[],
  ): Promise<Resolver> {
    const userRemappings = await Promise.all(
      userRemappingStrings.map((remappingString) =>
        validateAndResolveUserRemapping(projectRoot, remappingString),
      ),
    );

    return new ResolverImplementation(projectRoot, userRemappings);
  }

  private constructor(
    projectRoot: string,
    userRemappings: ResolvedUserRemapping[],
  ) {
    this.#projectRoot = projectRoot;
    this.#userRemappings = userRemappings;
    this.#dependencyMaps.set(PROJECT_ROOT_SOURCE_NAME_SENTINEL, new Map());
  }

  public async resolveProjectFile(
    absoluteFilePath: string,
  ): Promise<ProjectResolvedFile> {
    return this.#mutex.exclusiveRun(async () => {
      if (!absoluteFilePath.startsWith(this.#projectRoot)) {
        throw new HardhatError(
          HardhatError.ERRORS.SOLIDITY.RESOLVING_INCORRECT_FILE_AS_PROJECT_FILE,
          {
            file: shortenPath(absoluteFilePath),
          },
        );
      }

      const relativeFilePath = path.relative(
        this.#projectRoot,
        absoluteFilePath,
      );

      // We first check if the file has already been resolved.
      //
      // Note that it may have recevied the right path, but with the wrong
      // casing. We don't care at this point, as it would just mean a cache
      // miss, and we proceed to get the right casing in that case.
      //
      // However, as most of the time these absolute paths are read from the file
      // system, they'd have the right casing in general.
      //
      // If we need to fetch the right casing, we'd have to recheck the cache,
      // to avoid re-resolving the file.
      let sourceName = fsPathToSourceNamePath(relativeFilePath);
      const cached = this.#resolvedFileBySourceName.get(sourceName);

      if (cached !== undefined) {
        /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a ProjectResolvedFile */
        return cached as ProjectResolvedFile;
      }

      let trueCasePath: string;
      try {
        trueCasePath = await getFileTrueCase(
          this.#projectRoot,
          relativeFilePath,
        );
      } catch (error) {
        ensureError(error, FileNotFoundError);

        throw new HardhatError(
          HardhatError.ERRORS.SOLIDITY.RESOLVING_NONEXISTENT_PROJECT_FILE,
          { file: shortenPath(absoluteFilePath) },
          error,
        );
      }

      // Now that we have the correct casing, we "fix" the source name.
      sourceName = fsPathToSourceNamePath(trueCasePath);

      // Maybe it was already resolved, so we need to check with the right
      // casing
      const resolvedWithTheRightCasing =
        this.#resolvedFileBySourceName.get(sourceName);
      if (resolvedWithTheRightCasing !== undefined) {
        /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      -- If it was, it's a ProjectResolvedFile */
        return resolvedWithTheRightCasing as ProjectResolvedFile;
      }

      // If this wasn't
      const pathWithTheRightCasing = path.join(this.#projectRoot, trueCasePath);

      const resolvedFile: ProjectResolvedFile = {
        type: ResolvedFileType.PROJECT_FILE,
        sourceName,
        path: pathWithTheRightCasing,
        content: await readUtf8File(pathWithTheRightCasing),
      };

      this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

      return resolvedFile;
    });
  }

  public async resolveNpmDependencyFile(
    npmModule: string,
  ): Promise<NpmPackageResolvedFile> {
    assertHardhatInvariant(
      false,
      `Trying to resolve npm dependency file ${npmModule} but this hasn't been implemented yet`,
    );
  }

  public async resolveImport(
    from: ResolvedFile,
    importPath: string,
  ): Promise<ResolvedFile> {
    return this.#mutex.exclusiveRun(async () => {
      let directImport = importPath;

      if (path.sep !== "/" && importPath.includes(path.sep)) {
        throw new HardhatError(
          HardhatError.ERRORS.SOLIDITY.IMPORT_PATH_WITH_WINDOWS_SEPARATOR,
          {
            importPath,
            from: shortenPath(from.fsPath),
          },
        );
      }

      if (importPath.startsWith("./") || importPath.startsWith("../")) {
        directImport = sourceNamePathJoin(
          path.dirname(from.sourceName),
          importPath,
        );

        if (from.type === ResolvedFileType.NPM_PACKGE_FILE) {
          if (!directImport.startsWith(from.package.rootSourceName)) {
            throw new HardhatError(
              HardhatError.ERRORS.SOLIDITY.ILLEGAL_PACKAGE_IMPORT,
              {
                importPath,
                from: shortenPath(from.fsPath),
              },
            );
          }
        } else {
          if (directImport.startsWith("../")) {
            throw new HardhatError(
              HardhatError.ERRORS.SOLIDITY.ILEGALL_PROJECT_IMPORT,
              {
                importPath,
                from: shortenPath(from.fsPath),
              },
            );
          }
        }
      }

      switch (from.type) {
        case ResolvedFileType.PROJECT_FILE:
          return this.#resolveImportFromProjectFile({
            from,
            importPath,
            directImport,
          });

        case ResolvedFileType.NPM_PACKGE_FILE:
          return this.#resolveImportFromNpmPackageFile({
            from,
            importPath,
            directImport,
          });
      }
    });
  }

  public getRemappings(): Remapping[] {
    const userRemappings = this.#userRemappings.map((remapping) => ({
      context: remapping.context,
      prefix: remapping.prefix,
      target: remapping.target,
    }));

    const remappings: Remapping[] = [];

    for (const [
      thePackage,
      dependenciesMap,
    ] of this.#dependencyMaps.entries()) {
      let context: string;

      if (thePackage === PROJECT_ROOT_SOURCE_NAME_SENTINEL) {
        context = "";
      } else {
        context = thePackage.rootSourceName;
      }

      for (const [importedPackage, dependency] of dependenciesMap.entries()) {
        // As `hardhat/console.sol` is resolved through npm, even if the
        // `hardhat/` folder exists in the root of the package/project, we
        // only remap that file.
        // We should revisit this if we exported more solidity files in the
        // hardhat package in the future.
        if (
          dependency !== PROJECT_ROOT_SOURCE_NAME_SENTINEL &&
          dependency.name === "hardhat"
        ) {
          const prefix = importedPackage + "/console.sol";
          const target = dependency.rootSourceName + "console.sol";

          remappings.push({ context, prefix, target });
        } else {
          const prefix = importedPackage + "/";

          const target =
            dependency === PROJECT_ROOT_SOURCE_NAME_SENTINEL
              ? ""
              : dependency.rootSourceName;

          remappings.push({ context, prefix, target });
        }
      }
    }

    // TODO: Always order this in a consistent way
    for (const [packageSourceName, prefixes] of this.#localPrefixesByPackage) {
      for (const prefix of prefixes) {
        remappings.push({
          context: packageSourceName.rootSourceName,
          prefix,
          target: packageSourceName.rootSourceName + prefix,
        });
      }
    }

    // We sort the remappings acording to the remappings selection rules, plus
    // the targets, which shouldn't be needed.
    remappings
      .sort((a, b) => a.target.localeCompare(b.target))
      .sort((a, b) => a.target.length - b.target.length)
      .sort((a, b) => a.prefix.localeCompare(b.prefix))
      .sort((a, b) => a.prefix.length - b.prefix.length)
      .sort((a, b) => a.context.localeCompare(b.context))
      .sort((a, b) => a.context.length - b.context.length);

    return [...userRemappings, ...remappings];
  }

  // >>>>>>>>>> BEGIN SECTION: Import resolution selection
  //
  // The private methods in this section are in charge of selecting which import
  // resolution technique to use, but they don't create any ResolvedFile.
  //
  // These techniques are:
  //  1. Resolving an import to a project file
  //  2. Resolving an import to an npm package remapped by the user
  //  3. Resolving an import from an npm package to one of its own files with a
  //     relative import
  //  4. Resolving an import from an npm package to one of its own files with a
  //     direct import â€” This case is different from 3, as without especial care
  //     it could be affected by one of the user remappings.
  //  5. Resolving an import to a different npm package using our own remmapings

  /**
   * Resolves an import from a project file.
   *
   * This method applies the user remappings, if necessary, and uses the
   * appropriate resolution technique.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but before applying any remapping.
   */
  async #resolveImportFromProjectFile({
    from,
    importPath,
    directImport,
  }: {
    from: ProjectResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<ResolvedFile> {
    const bestUserRemapping = selectBestRemapping(
      from.sourceName,
      directImport,
      this.#userRemappings,
    );

    if (bestUserRemapping !== undefined) {
      const remappedDirectImport = applyValidRemapping(
        directImport,
        bestUserRemapping,
      );

      // Special case, where a user remapping's target is an npm pacakge
      if (bestUserRemapping.targetNpmPackage !== undefined) {
        // This weird syntax is because TS doesn't realize that
        // bestUserRemapping is Required<UserRemapping> here
        const remapping: Required<ResolvedUserRemapping> = {
          ...bestUserRemapping,
          targetNpmPackage: bestUserRemapping.targetNpmPackage,
        };

        return this.#resolveImportToNpmPackageRemappedByUser({
          from,
          importPath,
          directImport: remappedDirectImport,
          remapping,
        });
      }

      if (
        !(await this.#isDirectImportLocal(
          this.#projectRoot,
          remappedDirectImport,
        ))
      ) {
        throw new HardhatError(
          HardhatError.ERRORS.SOLIDITY.ILLEGAL_PROJECT_IMPORT_AFTER_REMAPPING,
          {
            importPath,
            from: shortenPath(from.fsPath),
            remapping: bestUserRemapping.rawFormat,
            remappedDirectImport,
          },
        );
      }

      return this.#resolveImportToProjectFile({
        from,
        importPath,
        pathWithinTheProject: sourceNamePathToFsPath(remappedDirectImport),
      });
    }

    if (await this.#isDirectImportLocal(this.#projectRoot, directImport)) {
      return this.#resolveImportToProjectFile({
        from,
        importPath,
        pathWithinTheProject: sourceNamePathToFsPath(directImport),
      });
    }

    return this.#resolveImportThroughNpm({
      from,
      importPath,
      directImport,
    });
  }

  /**
   * Resolves an import from an npm file.
   *
   * This method does not apply any remapping that may be present in the npm
   * package.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but without applying any remapping.
   */
  async #resolveImportFromNpmPackageFile({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<ResolvedFile> {
    // If we wanted to apply its own remappings, this would be the place.
    // Initially we won't support it.

    //
    if (directImport.startsWith(from.package.rootSourceName)) {
      return this.#resolveRelativeImportFromNpmPackage({
        from,
        importPath,
        directImport,
      });
    }

    // This was already a direct import, and may be to the same package.
    // As we allow this imports in the local project files, we should also allow
    // them on npm packages. If we don't projects won't be easily distributable
    // through npm, even if they don't use remappings.
    if (await this.#isDirectImportLocal(from.package.rootPath, directImport)) {
      const resolvedFile = await this.#resolveLocalImportFromNpmPackage({
        from,
        importPath,
        directImport,
      });

      let prefixesNeededByPackage = this.#localPrefixesByPackage.get(
        from.package,
      );

      if (prefixesNeededByPackage === undefined) {
        prefixesNeededByPackage = new Set();
        this.#localPrefixesByPackage.set(from.package, prefixesNeededByPackage);
      }

      prefixesNeededByPackage.add(
        this.#getDirectImportLocalPrefix(directImport),
      );

      return resolvedFile;
    }

    return this.#resolveImportThroughNpm({
      from,
      importPath,
      directImport,
    });
  }

  /**
   * This method resolves an import that has to go through the npm resolution
   * process and selects the appropriate technique to resolve it.
   *
   * This method does not apply nor define any remapping, but it populates the
   * `#dependencyMaps` with dependencies that each package uses, so that we can
   * create all the necessary remappings at the end of the resolution process.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but without applying any remapping.
   */
  async #resolveImportThroughNpm({
    from,
    importPath,
    directImport,
  }: {
    from: ResolvedFile;
    importPath: string;
    directImport: string;
  }): Promise<ResolvedFile> {
    const parsedDirectImport = this.#parseNpmDirectImport(directImport);

    if (parsedDirectImport === undefined) {
      throw new HardhatError(HardhatError.ERRORS.SOLIDITY.INVALID_NPM_IMPORT, {
        importPath,
        from: shortenPath(from.fsPath),
      });
    }

    const dependencyMapsKey =
      from.type === ResolvedFileType.PROJECT_FILE
        ? PROJECT_ROOT_SOURCE_NAME_SENTINEL
        : from.package;

    if (!this.#dependencyMaps.has(dependencyMapsKey)) {
      this.#dependencyMaps.set(dependencyMapsKey, new Map());
    }

    const dependenciesMap = this.#dependencyMaps.get(dependencyMapsKey);

    assertHardhatInvariant(
      dependenciesMap !== undefined,
      "We set the dependency map right above",
    );

    if (!dependenciesMap.has(parsedDirectImport.package)) {
      let newDependency:
        | ResolvedNpmPackage
        | typeof PROJECT_ROOT_SOURCE_NAME_SENTINEL;

      const baseResolutionDirectory =
        from.type === ResolvedFileType.PROJECT_FILE
          ? this.#projectRoot
          : from.package.rootPath;

      const packageJsonResolution = resolve(
        parsedDirectImport.package + "/package.json",
        baseResolutionDirectory,
      );

      if (packageJsonResolution.success === false) {
        if (packageJsonResolution.error === ResolutionError.MODULE_NOT_FOUND) {
          throw new HardhatError(
            HardhatError.ERRORS.SOLIDITY.IMPORTED_NPM_DEPENDENCY_NOT_INSTALLED,
            {
              from: shortenPath(from.fsPath),
              importPath,
            },
          );
        }

        throw new HardhatError(
          HardhatError.ERRORS.SOLIDITY.IMPORTED_NPM_DEPENDENCY_THAT_USES_EXPORTS,
          { from: shortenPath(from.fsPath), importPath },
        );
      }

      const packageJsonPath = packageJsonResolution.absolutePath;

      const packageJson = await readJsonFile<{ name: string; version: string }>(
        packageJsonPath,
      );

      if (isPackageJsonFromProject(packageJsonPath, this.#projectRoot)) {
        newDependency = PROJECT_ROOT_SOURCE_NAME_SENTINEL;
      } else {
        const name = packageJson.name;
        const version = isPackageJsonFromMonorepo(
          packageJsonPath,
          this.#projectRoot,
        )
          ? "local"
          : packageJson.version;

        const npmPackage: ResolvedNpmPackage = {
          name,
          version,
          rootPath: path.dirname(packageJsonPath),
          rootSourceName: npmPackageToRootSourceName(name, version),
        };

        newDependency = npmPackage;
      }

      dependenciesMap.set(parsedDirectImport.package, newDependency);
    }

    const dependency = dependenciesMap.get(parsedDirectImport.package);
    assertHardhatInvariant(
      dependency !== undefined,
      "We set the dependency right above",
    );

    if (dependency === PROJECT_ROOT_SOURCE_NAME_SENTINEL) {
      return this.#resolveImportToProjectFile({
        from,
        importPath,
        // If we import a file through npm and end up in the Hardhat project,
        // we are going to remap the package name to "", so that the path
        // section of the parsed direct is in fact the directImport in the
        // context of the package.
        pathWithinTheProject: sourceNamePathToFsPath(parsedDirectImport.path),
      });
    }

    return this.#resolveImportToNpmPackage({
      from,
      importPath,
      importedPackage: dependency,
      pathWithinThePackage: sourceNamePathToFsPath(parsedDirectImport.path),
    });
  }

  // >>>>>>>>>> END SECTION: Import resolution selection

  // >>>>>>>>>> BEGIN SECTION: Import resolution techniques
  //
  // The private methods in this section implement the different import
  // import resolution techniques, which have been explained in the previous
  // section.

  /**
   * This method implements the import resolution technique number 1: Importing
   * a file that is within the project. Note that this method applies both to
   * imports from project files as well as imports from npm packages that may
   * have the project as a dependency.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param pathWithinTheProject The path within the project to import, after
   * normalizing relative paths, applying user remappings and/or stripping the
   * npm package name.
   */
  async #resolveImportToProjectFile({
    from,
    importPath,
    pathWithinTheProject,
  }: {
    from: ResolvedFile;
    importPath: string;
    pathWithinTheProject: string;
  }): Promise<ProjectResolvedFile> {
    const sourceName = fsPathToSourceNamePath(pathWithinTheProject);
    const cached = this.#resolvedFileBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a ProjectResolvedFile */
      return cached as ProjectResolvedFile;
    }

    // This is a project file, so if it was imported from a local file, this
    // is the direct import, without any remapping or necessary consideration.
    // If this was imported from an npm package, we are remapping the package
    // name to "", so that the direct import is the same as the relative path.
    const relativePath = pathWithinTheProject;
    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: relativePath,
      absolutePathToValidateFrom: this.#projectRoot,
    });

    const filePath = path.join(this.#projectRoot, relativePath);

    const resolvedFile: ProjectResolvedFile = {
      type: ResolvedFileType.PROJECT_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
    };

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 2: A project
   * file has an import that should be resolved to a file in an npm package due
   * to a user remapping.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * and applying the user remapping.
   * @param remapping The remapping that was applied.
   */
  async #resolveImportToNpmPackageRemappedByUser({
    from,
    importPath,
    directImport,
    remapping,
  }: {
    from: ProjectResolvedFile;
    importPath: string;
    directImport: string;
    remapping: Required<ResolvedUserRemapping>;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = directImport;
    const cached = this.#resolvedFileBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    const relativeFilePath = sourceNamePathToFsPath(
      path.relative(remapping.targetNpmPackage.rootSourceName, directImport),
    );

    // We don't add the dependency to `this.#dependencyMaps` because we
    // don't need a new remapping for this package, as it's already
    // remapped by the user.

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: relativeFilePath,
      absolutePathToValidateFrom: remapping.targetNpmPackage.rootPath,
    });

    const filePath = path.join(
      remapping.targetNpmPackage.rootPath,
      relativeFilePath,
    );

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: remapping.targetNpmPackage,
    };

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 3: A file
   * from an npm package is importing another file from the same package with a
   * relative import.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths.
   * It must start with the package's root source name.
   */
  async #resolveRelativeImportFromNpmPackage({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = directImport;
    const cached = this.#resolvedFileBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    const relativePath = sourceNamePathToFsPath(
      path.relative(from.package.rootSourceName, directImport),
    );

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: relativePath,
      absolutePathToValidateFrom: from.package.rootPath,
    });

    const filePath = path.join(from.package.rootPath, relativePath);

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: from.package,
    };

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);
    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 4: A file
   * from an npm package is importing another file from the same package with a
   * direct import.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths.
   * The direct import must be considered local within the package, according to
   * the rules of the `#isDirectImportLocal` method.
   */
  async #resolveLocalImportFromNpmPackage({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = from.package.rootSourceName + directImport;
    const cached = this.#resolvedFileBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: fsPathToSourceNamePath(directImport),
      absolutePathToValidateFrom: from.package.rootPath,
    });

    const filePath = path.join(from.package.rootPath, directImport);

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: from.package,
    };

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);
    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 5: A file,
   * within the project or from an npm pacakge, is importing a file from a
   * different npm package.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param importedPackage The NpmPackage that is being imported.
   * @param pathWithinThePackage The path to the file to import, within the
   * package. That means, after parsing the direct import, and stripping the
   * package part.
   */
  async #resolveImportToNpmPackage({
    from,
    importPath,
    importedPackage,
    pathWithinThePackage,
  }: {
    from: ResolvedFile;
    importPath: string;
    importedPackage: ResolvedNpmPackage;
    pathWithinThePackage: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName =
      importedPackage.rootSourceName +
      fsPathToSourceNamePath(pathWithinThePackage);
    const cached = this.#resolvedFileBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: pathWithinThePackage,
      absolutePathToValidateFrom: importedPackage.rootPath,
    });

    const filePath = path.join(importedPackage.rootPath, pathWithinThePackage);

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: importedPackage,
    };

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  // >>>>>>>>>> END SECTION: Import resolution techniques

  /**
   * This method returns true if a direct import should be considered an import
   * to a local file when evaluated in the context of the Hardhat project.
   */
  async #isDirectImportLocal(
    projectOrPackageRoot: string,
    directImport: string,
  ): Promise<boolean> {
    if (directImport === "hardhat/console.sol") {
      return false;
    }

    const slash = directImport.indexOf("/");

    // If it's a file in the root directory
    if (slash === -1) {
      return true;
    }

    const firstDirectory = directImport.substring(0, slash);

    // TODO: Cache this?
    return exists(path.join(projectOrPackageRoot, firstDirectory));
  }

  /**
   * Returns the prefix that is used by #isDirectImportLocal to determine if a
   * direct import is local.
   *
   * NOTE: This method does not support `hardhat/console.sol`.
   */
  #getDirectImportLocalPrefix(directImport: string): string {
    const slash = directImport.indexOf("/");

    // If it's a file in the root directory
    if (slash === -1) {
      return directImport;
    }

    const firstDirectory = directImport.substring(0, slash + 1);

    return firstDirectory;
  }

  /**
   * This is an utility method that validates the existance and casing of an
   * imported file as part of the different resolution techniques.
   *
   * `from` and `importPath` are used to provide a user-friendly error message,
   * but the actual validation is done using `relativePathToValidate` and
   * `absolutePathToValidateFrom`.
   *
   * @param from The file with the import.
   * @param importPath The import path, as written in the source code.
   * @param relativePathToValidate The relative path to validate its existance.
   * @param absolutePathToValidateFrom The absolute path from in which the
   * relative path is.
   */
  async #validateExistanceAndCasingOfImport({
    from,
    importPath,
    relativePathToValidate,
    absolutePathToValidateFrom,
  }: {
    from: ResolvedFile;
    importPath: string;
    relativePathToValidate: string;
    absolutePathToValidateFrom: string;
  }) {
    let trueCasePath: string;
    try {
      trueCasePath = await getFileTrueCase(
        absolutePathToValidateFrom,
        relativePathToValidate,
      );
    } catch (error) {
      ensureError(error, FileNotFoundError);

      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.IMPORTED_FILE_DOESNT_EXIST,
        { importPath, from: shortenPath(from.fsPath) },
        error,
      );
    }

    if (relativePathToValidate !== trueCasePath) {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.IMPORTED_FILE_WITH_ICORRECT_CASING,
        {
          importPath,
          from: shortenPath(from.fsPath),
          correctCasing: fsPathToSourceNamePath(trueCasePath),
        },
      );
    }
  }

  /**
   * Parses a direct import as if it were an npm import, returning `undefined`
   * if the format is invalid.
   */
  #parseNpmDirectImport(directImport: string):
    | {
        package: string;
        path: string;
      }
    | undefined {
    const directImportPattern =
      /^(?<package>(?:@[a-z0-9-~._]+\/)?[a-z0-9-~][a-z0-9-~._]*)\/(?<path>.*)$/;

    const match = directImportPattern.exec(directImport);

    if (match === null) {
      return undefined;
    }

    assertHardhatInvariant(
      match.groups !== undefined,
      "Groups should be defined because they are part of the pattern",
    );

    return { package: match.groups.package, path: match.groups.path };
  }
}

async function validateAndResolveUserRemapping(
  projectRoot: string,
  remappingString: string,
): Promise<ResolvedUserRemapping> {
  const remapping = parseRemappingString(remappingString);

  if (remapping === undefined) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_WITH_INVALID_SYNTAX,
      {
        remapping: remappingString,
      },
    );
  }

  if (remapping.context.startsWith("npm/")) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.USER_REMAPPING_WITH_NPM_CONTEXT,
      { remapping: remappingString },
    );
  }

  if (!remapping.target.startsWith("npm/")) {
    return { ...remapping, rawFormat: remappingString };
  }

  const parsed = parseNpmRemappingTarget(remapping.target);

  if (parsed === undefined) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_WITH_INVALID_SYNTAX,
      { remapping: remappingString },
    );
  }

  const { packageName, packageVersion } = parsed;

  const dependencyPackageJsonResolution = resolve(
    `${packageName}/package.json`,
    projectRoot,
  );

  if (dependencyPackageJsonResolution.success === false) {
    if (
      dependencyPackageJsonResolution.error === ResolutionError.MODULE_NOT_FOUND
    ) {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.REMAPPING_TO_UNINSTALLED_PACKAGE,
        { remapping: remappingString, package: packageName },
      );
    }

    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_TO_PACKAGE_USING_EXPORTS,
      { remapping: remappingString, package: packageName },
    );
  }

  const dependencyPackageJsonPath =
    dependencyPackageJsonResolution.absolutePath;

  if (isPackageJsonFromMonorepo(dependencyPackageJsonPath, projectRoot)) {
    if (packageVersion !== "local") {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.REMAPPING_NPM_PACKAGE_AS_MONOREPO,
        {
          remapping: remappingString,
          pacakge: packageName,
          version: packageVersion,
        },
      );
    }
  }

  if (isPackageJsonFromProject(dependencyPackageJsonPath, projectRoot)) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_HARDHAT_PROJECT_AS_MONOREPO_PACKAGE,
      { remapping: remappingString, package: packageName },
    );
  }

  if (isPackageJsonFromNpmPackage(dependencyPackageJsonPath)) {
    const dependencyPackageJson = await readJsonFile<{ version: string }>(
      dependencyPackageJsonPath,
    );

    if (dependencyPackageJson.version !== packageVersion) {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.REMAPPING_INCORRECT_VERSION,
        {
          remapping: remappingString,
          package: packageName,
          expectedVersion: packageVersion,
          actualVersion: dependencyPackageJson.version,
        },
      );
    }
  }

  const npmPackage: ResolvedNpmPackage = {
    name: packageName,
    version: packageVersion,
    rootPath: path.dirname(dependencyPackageJsonPath),
    rootSourceName: npmPackageToRootSourceName(packageName, packageVersion),
  };

  return {
    ...remapping,
    targetNpmPackage: npmPackage,
    rawFormat: remappingString,
  };
}

function parseNpmRemappingTarget(remappingTarget: string):
  | {
      packageName: string;
      packageVersion: string;
    }
  | undefined {
  const npmTargetPattern =
    /^npm\/(?<package>(?:@[a-z0-9-~._]+\/)?[a-z0-9-~][a-z0-9-~._]*)@(?<version>local|\d+\.\d+\.\d+)\//;

  const match = npmTargetPattern.exec(remappingTarget);

  if (match === null) {
    return undefined;
  }

  assertHardhatInvariant(
    match.groups !== undefined,
    "Groups should be defined because they are part of the pattern",
  );

  return {
    packageName: match.groups.package,
    packageVersion: match.groups.version,
  };
}

function npmPackageToRootSourceName(name: string, version: string): string {
  return `npm/${name}@${version}/`;
}

function isPackageJsonFromMonorepo(
  packageJsonPath: string,
  projectRoot: string,
): boolean {
  return (
    !packageJsonPath.includes("node_modules") &&
    !packageJsonPath.startsWith(projectRoot)
  );
}

function isPackageJsonFromProject(
  packageJsonPath: string,
  projectRoot: string,
): boolean {
  return (
    !packageJsonPath.includes("node_modules") &&
    packageJsonPath.startsWith(projectRoot)
  );
}

function isPackageJsonFromNpmPackage(packageJsonPath: string): boolean {
  return packageJsonPath.includes("node_modules");
}

/**
 * Transforms an fs path into a sourceName or import path, by normalizing their
 * path separators to /.
 *
 * Note that source
 *
 * Note: This function is exported for testing purposes, but it's not meant to
 * be used outside of the resolver.
 */
export function fsPathToSourceNamePath(fsPath: string): string {
  if (path.sep === "/") {
    return fsPath;
  }

  return fsPath.replace(/\\/g, "/");
}

/**
 * Transforms a sourceName or import path into an fs path, by normalizing their
 * path separators to /.
 *
 * Note: This function is exported for testing purposes, but it's not meant to
 * be used outside of the resolver.
 */
export function sourceNamePathToFsPath(sourceNamePath: string): string {
  if (path.sep === "/") {
    return sourceNamePath;
  }

  return sourceNamePath.replace(/\//g, "\\");
}

/**
 * The equivalent of path.join but for sourceName or import paths, not fs paths.
 */
function sourceNamePathJoin(...parts: string[]): string {
  return fsPathToSourceNamePath(path.join(...parts));
}
